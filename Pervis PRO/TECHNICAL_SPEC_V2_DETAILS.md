# 技术规格说明书 V2.0：细节拆解与风险分析

## 1. 核心问题答疑：浏览器能识别标签吗？(MVP 风险评估)

您担心的核心点是：**"素材存在 NAS 里，浏览器还能不能正常通过标签搜到它？"**

### 结论：✅ 完全可以，0 风险。
**技术原理 (Metabase Abstraction)**：
- **标签在哪里？** 标签 (如 "快乐", "雨天") 存储在我们的 **SQLite 数据库**中，而不是物理文件里。
- **浏览器怎么查？** 浏览器查询对象是 **数据库**。即使用户拔掉网线、NAS 断连，浏览器依然能搜出 "asset_888 是雨天场景"，只是无法播放画面而已。
- **AI 怎么看？**
    - 在"启动器"扫描阶段，后台 Python 进程会直接读取 NAS 文件的**关键帧**传给 AI 模型。
    - AI 分析完，把标签存入数据库。
    - **即使是 MVP 阶段，这套逻辑也是原生支持的。**

---

## 2. 环节颗粒度拆解 (Granular Breakdown)

我们将"不着急改代码"的指令转化为详细的"施工图纸"。以下是每个环节的完成标准：

### 阶段一：启动器 (The "Ops" Console) - 完工标准
> **目标**：把 NAS 这里当成"本地硬盘"一样接管。

1.  **路径挂载 (Mounting)**
    -   **做到哪一步？**：界面上有一个列表，显示 `Z:\` `\\192.168.1.50\素材`。
    -   **细节**：支持 "移除" 操作。移除时不删文件，只删数据库记录。
2.  **扫描与发现 (Scanning)**
    -   **做到哪一步？**：点击扫描，进度条走完，显示 "发现 500 个新视频"。
    -   **细节**：
        -   **去重**：如果同一文件扫描两次，不会重复入库 (基于路径 Hash)。
        -   **过滤**：自动忽略 `.DS_Store`, `.tmp` 等垃圾文件。
3.  **预处理 (Pre-processing)**
    -   **做到哪一步？**：后台生成 720p 代理文件 (Proxy) 存到本地缓存目录。
    -   **原因**：NAS 原始素材可能是 4K/8K ProRes，浏览器跑不动。**必须**在启动器里生成一份轻量版给浏览器看。

### 阶段二：后端 (The "Bridge") - 完工标准
> **目标**：欺骗浏览器，让它以为视频就在本地。

1.  **流媒体代理 (Streaming Route)**
    -   **做到哪一步？**：可以在 Chrome 里通过 `http://localhost:8000/stream?path=Z:\test.mp4` 播放视频。
    -   **细节**：支持 `Range Request` (拖动进度条)，这是流媒体播放的核心。
2.  **AI 分析服务 (Analyzer)**
    -   **做到哪一步？**：能读取绝对路径 (`Z:\...`) 进行截图分析。
    -   **细节**：无需将文件复制到工程目录 (Zero-Copy Analysis)。

### 阶段三：浏览器 (The "Canvas") - 完工标准
> **目标**：用户无感。

1.  **标签展示**
    -   **做到哪一步？**：卡片上显示自动生成的标签。支持人工修改。
    -   **细节**：修改后立即回写数据库。
2.  **播放体验**
    -   **做到哪一步？**：点击播放时，优先请求 **代理文件(Proxy)** (存在本地SSD)，如果是图片则直接请求缩略图。
    -   **兜底**：如果代理文件还没生成，尝试直接流式传输 NAS 原片 (可能会卡顿，但在预期内)。

---

## 3. MVP 潜在风险与规避

| 风险点 | 现象 | 规避方案 (Mitigation) |
| :--- | :--- | :--- |
| **NAS 掉线** | 浏览器能搜到卡片，但点击播放转圈 | **UI 优化**：检测到文件不可达时，卡片变灰并显示 "Offline"。 |
| **缩略图生成慢** | 刚添加完路径，浏览器里全是黑块 | **默认图**：先显示 "AI正在分析中..." 的占位图。 |
| **标签不准** | AI 把"红衣服"识别成"粉衣服" | **Web端修正**：MVP 必须提供"右键->编辑标签"功能。 |

## 4. 总结
我们目前的架构完全支持"浏览器识别标签"，逻辑是解耦的。
**下一步建议**：先不急着开发 UI，我们可以先写一个小的 Python 脚本，**模拟**"扫描 NAS -> 存库 -> 查标签"的全过程，用日志证明这条路是通的。
