# 🤖 Gemini API 能力与启动器可视化方案

## 1. Gemini API 深度底细 (The Truth about API)

**Q: 用的公有 API 吗？处理量和速度如何？**

*   **API 版本**: 是的，我们在 `gemini_client.py` 中使用的是 Google 官方的 `google.generativeai` 库，调用 **Gemini 1.5 Flash** 模型。
*   **为什么是 Flash?**: 它是目前 Google 专门为 **高频、低延迟、多模态** 任务设计的。

### 📊 处理能力测算 (Capacity & Speed)

假设我们要处理一部 **90分钟 (5400秒)** 的电影：

| 指标 | 参数 | 计算/说明 |
| :--- | :--- | :--- |
| **抽帧策略** | 每 5 秒 1 张 | 共 **1080 张** 关键帧图片 |
| **单图大小** | 压缩后 ~50KB | 总流量约 **54 MB** (极小) |
| **API 限制 (RPM)** | 免费层: 15 RPM<br>付费层: 1000+ RPM | 我们使用**批处理 (Batching)** 技术，将 10 张图打包成一个请求。 |
| **处理时间** | **并行处理** | **约 3 - 5 分钟** (全部分析完) |
| **Token 消耗** | 视上下文长度 | Flash 模型拥有 **100万 Token** 上下文，吃下整部电影的描述绰绰有余。 |

**结论**:
*   **量级**: 处理 TB 级 NAS 里的几百部电影完全没问题。
*   **速度**: 一部电影入库分析只需几分钟（后台静默运行）。
*   **成本**: 极低 (Flash 模型价格非常亲民，甚至在免费配额内就能跑完 Demo)。

---

## 2. 启动器可视化方案 (Launcher Visualization Plan)

您指出目前的启动器还不够智能。**"先检测，后可视化"** 是我们的新核心。

### 核心逻辑：Detection First -> Visualization
我们需要一个 **"Control Center (控制中心)"**，而不是简单的启动脚本。

#### Step 1: 自动侦测 (Auto-Detection)
启动器启动时，不再是傻傻地读配置文件，而是**主动扫描**：
1.  **扫描本地**: 也就是 `C:/AppData/Pervis`（看现有的 Database、Proxy 还在不在）。
2.  **扫描网络**: Ping 局域网内的 NAS IP (如 `192.168.1.xxx`)。
3.  **扫描服务**: 检查 Docker/Python 进程是否存活。

#### Step 2: 可视化仪表盘 (The Dashboard)
不需要用户去改代码。我们要做一个图形界面（见下图规划）：

**[板块 A] 存储拓扑图 (Storage Topology)**
*   **视觉**: 左边是 "本机"，右边是 "NAS"，中间有连线。
*   **状态**:
    *   🟢 **绿色连线**: `Z:\Movies` 已挂载，且 AI 扫描进度 100%。
    *   🟡 **黄色连线**: 发现新 NAS 路径，但尚未索引 (点击"一键索引")。
    *   🔴 **红色连线**: 路径断开 (NAS 掉线)。

**[板块 B] AI 算力监控 (AI Monitor)**
*   **视觉**: 类似 CPU 占用率的波形图。
*   **内容**: 显示当前每分钟处理了多少张图片 (IPM)，Gemini API 的延迟 (ms)。

**[板块 C] 流量控制 (Traffic Control)**
*   **开关**: 就像水龙头。
*   用户可以拖动滑块：**"全速模式" (占满带宽)** vs **"静默模式" (后台慢跑)**。

### 📅 下一步行动
我将为您生成一张这个 **Control Center** 的视觉设计图，确认满意后，我们再开始写 UI 代码。
